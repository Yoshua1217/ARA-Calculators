<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARA Multi-Trunk Circumference Calculator</title>
  <style>
    :root { --radius:12px; --dark:#111; --light:#f2f2f2; }
    .card, .card * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:24px; }
    .card { max-width: 840px; margin:0 auto; padding:20px; border:1px solid #ddd; border-radius:var(--radius); }
    h1 { margin:0 0 10px; font-size:1.6rem; }
    .sub { margin:0 0 16px; color:#555; }
    .note { width:100%; background:#f7f7f7; padding:10px 12px; border-radius:var(--radius); border:1px solid #e7e7e7; margin-bottom:16px; }

    .help { margin:8px 0 6px; color:#444; font-size:.95rem; }
    .unit-toggle { display:flex; gap:8px; margin:0 0 12px; }
    .toggle-btn { padding:8px 12px; border:1px solid #ccc; border-radius:8px; background: var(--light); cursor:pointer; user-select:none; }
    .toggle-btn.active { background: var(--dark); color:#fff; border-color: var(--dark); }
    .toggle-btn:focus-visible { outline:2px solid var(--dark); outline-offset:2px; }

    label { display:block; margin:10px 0 6px; font-weight:600; }
    input[type="number"], textarea {
      width:100%; display:block; padding:10px; border:1px solid #ccc; border-radius:8px; font-size:1rem;
    }
    textarea { min-height: 80px; resize: vertical; }
    input.error { border-color:#e11900; box-shadow:0 0 0 3px rgba(225,25,0,.15); outline:none; }

    .grid { display:grid; grid-template-columns: 1.3fr 1fr; gap:18px; align-items:start; }
    .row { display:grid; grid-template-columns: 1fr; gap:6px; align-items:start; }
    .trunks { display:flex; flex-direction:column; gap:10px; }

    .btn-row { display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; }
    button, a.button { padding:10px 14px; border:0; border-radius:8px; cursor:pointer; display:inline-block; text-decoration:none; text-align:center; }
    .btn-primary { background: var(--dark); color:#fff; }
    .btn-secondary { background:#e9e9e9; color:#111; }
    .btn-ghost { background:#f5f5f5; color:#111; }
    .btn-secondary.active { background: var(--dark); color:#fff; } /* Generate Description dark when active */
    button[disabled]{ opacity:.6; cursor:not-allowed; }

    .hint { font-size:.86rem; color:#b2271a; display:none; }
    .hint.show { display:block; }
    .largest-label { font-weight:800; }
    .badge { display:inline-block; margin-left:8px; padding:2px 8px; border-radius:999px; background:#111; color:#fff; font-size:.75rem; vertical-align:middle; }
    .badge.hide { display:none; }

    .result { margin-top:16px; font-size:1.05rem; }
    .result p { margin:6px 0; }
    .foot { margin-top:18px; font-size:.9rem; color:#666; line-height:1.35; }
    form { margin:0; }
    .tiny { color:#666; font-size:.85rem; }

    .descwrap { margin-top:16px; }
    .descbox {
      width:100%; min-height:120px; background:#fafafa;
      border:1px solid #e6e6e6; border-radius:10px; padding:12px;
      white-space:normal; font-family: inherit; /* regular text */
    }
    .descbox ul { margin: 6px 0 6px 20px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>ARA Multi-Trunk Circumference Calculator</h1>
    <p class="sub">Ancient Roots Alberta</p>

    <div class="note">
      <strong>Method:</strong> Convert each trunk’s <em>circumference → diameter</em> (<code>D = C / π</code>).
      Let the largest diameter be <code>Dmax</code>. Combined diameter =
      <code>Dmax + 0.5 × sum(other D)</code>. Equivalent circumference =
      <code>π × combined diameter</code>.
    </div>

    <p class="help"><strong>Input units:</strong> applies to each trunk’s <em>circumference</em>.</p>
    <div class="unit-toggle" role="group" aria-label="Input units">
      <button type="button" id="unit-m"  class="toggle-btn active" aria-pressed="true">Meters (m)</button>
      <button type="button" id="unit-ft" class="toggle-btn" aria-pressed="false">Feet (ft)</button>
    </div>

    <form id="form" action="#">
      <div class="grid">
        <!-- LEFT: trunk entries -->
        <div>
          <div class="trunks" id="trunk-list"><!-- rows injected here --></div>
          <div class="btn-row" style="margin-top:10px;">
            <button type="button" id="add"    class="btn-secondary">Add trunk</button>
            <button type="button" id="remove" class="btn-secondary">Remove last</button>
            <button type="button" id="sort"   class="btn-ghost" title="Sort by diameter (desc)">Sort by diameter</button>
          </div>
        </div>

        <!-- RIGHT: bulk paste -->
        <div>
          <label for="bulk">Bulk paste (numbers only, any separators)</label>
          <textarea id="bulk" placeholder="e.g. 1.72, 0.98 1.10
2.05
0.77"></textarea>
          <div class="tiny">Uses current unit (<span id="unit-tag">m</span>). Ignores text; keeps positive numbers only.</div>
          <div class="tiny"><em>Make sure your measurements match the unit selected at the top (Meters/Feet).</em></div>
          <div class="btn-row" style="margin-top:10px;">
            <button type="button" id="fill" class="btn-ghost">Fill trunks from bulk</button>
            <button type="button" id="clear-bulk" class="btn-ghost">Clear bulk</button>
          </div>
        </div>
      </div>

      <div class="btn-row" style="margin-top:16px;">
        <button type="submit"  class="btn-primary">Calculate</button>
        <button type="button" id="copy"   class="btn-secondary" disabled title="Copies equivalent circumference in meters only">Copy result (m)</button>
        <button type="reset"  id="reset"  class="btn-secondary">Reset</button>
      </div>
    </form>

    <div class="result" id="out">
      <p><strong>Equivalent circumference:</strong> <span id="ceq">—</span></p>
      <p><strong>Equivalent diameter:</strong> <span id="deq">—</span></p>
      <p id="used">—</p>
    </div>

    <!-- Description generator -->
    <div class="descwrap">
      <div class="btn-row">
        <button type="button" id="gendesc" class="btn-secondary" title="Create a bullet list summary">Generate description</button>
        <button type="button" id="copydesc" class="btn-ghost" disabled>Copy description</button>
      </div>
      <div id="desc" class="descbox" aria-live="polite">—</div>
    </div>

    <div class="foot">
      Outputs show both meters and feet, rounded to 2 decimals. For ARA nominations, paste <strong>pure numbers in meters</strong> (no units) — use the Copy button above.
    </div>
  </div>

  <script>
    const PI = Math.PI, FT_PER_M = 3.28084, M_PER_FT = 0.3048;
    const $ = s => document.querySelector(s);

    const form = $('#form');
    const list = $('#trunk-list');
    const addBtn = $('#add');
    const remBtn = $('#remove');
    const sortBtn = $('#sort');
    const copyBtn = $('#copy');
    const outC = $('#ceq');
    const outD = $('#deq');
    const outUsed = $('#used');
    const unitM = $('#unit-m');
    const unitFt = $('#unit-ft');
    const bulk = $('#bulk');
    const unitTag = $('#unit-tag');
    const genDescBtn = $('#gendesc');
    const copyDescBtn = $('#copydesc');
    const descBox = $('#desc');

    let inputUnit = 'm';     // 'm' or 'ft'
    let lastMetersCirc = ''; // for Copy (m)
    let lastCalc = null;     // detailed calc for description
    let trunkCount = 0;
    const MAX_TRUNKS = 60;

    function fmt2(x){ return Number.isFinite(x) ? x.toFixed(2) : '—'; }

    function markDescDirty(){
      descBox.textContent = '—';
      copyDescBtn.disabled = true;
      genDescBtn.classList.remove('active');
    }

    function addTrunk(value=''){
      if (trunkCount >= MAX_TRUNKS) return;
      trunkCount++;
      const row = document.createElement('div');
      row.className = 'row';
      row.dataset.index = String(trunkCount);

      const labelWrap = document.createElement('div');
      const label = document.createElement('label');
      label.htmlFor = `c-${trunkCount}`;
      label.className = 'trunk-label';
      label.textContent = `Trunk ${trunkCount} circumference (${inputUnit})`;

      const badge = document.createElement('span');
      badge.className = 'badge hide';
      badge.textContent = 'Largest';

      labelWrap.appendChild(label);
      labelWrap.appendChild(badge);

      const inp = document.createElement('input');
      inp.id = `c-${trunkCount}`;
      inp.type = 'number';
      inp.step = '0.01';
      inp.inputMode = 'decimal';
      inp.placeholder = inputUnit === 'm' ? 'e.g. 1.75' : 'e.g. 5.74';
      if (value !== '') inp.value = value;

      const hint = document.createElement('div');
      hint.className = 'hint';

      row.appendChild(labelWrap);
      row.appendChild(inp);
      row.appendChild(hint);
      list.appendChild(row);

      inp.addEventListener('input', () => { inp.classList.remove('error'); hideHint(hint); markDescDirty(); });
      inp.addEventListener('blur', () => {
        const v = parseFloat(inp.value);
        if (Number.isFinite(v) && v > 0) maybeOutlierHint(v, hint); else hideHint(hint);
      });
    }

    function removeTrunk(){
      if (trunkCount <= 1) return;
      list.lastElementChild?.remove();
      trunkCount--;
      renumberLabels();
      markDescDirty();
    }

    function renumberLabels(){
      Array.from(list.querySelectorAll('.trunk-label')).forEach((lab, i) => {
        lab.textContent = `Trunk ${i+1} circumference (${inputUnit})`;
      });
    }

    function getInputs(){
      return Array.from(list.querySelectorAll('input[type="number"]'));
    }

    function showHint(hEl, msg){ hEl.textContent = msg; hEl.classList.add('show'); }
    function hideHint(hEl){ hEl.textContent = ''; hEl.classList.remove('show'); }

    function maybeOutlierHint(val, hEl){
      if (inputUnit === 'm') {
        if (val < 0.20) showHint(hEl, 'This seems unusually small — check units/decimal?');
        else if (val > 12) showHint(hEl, 'This seems unusually large — check units?');
        else hideHint(hEl);
      } else {
        if (val < 0.66) showHint(hEl, 'This seems unusually small — check units/decimal?');
        else if (val > 40) showHint(hEl, 'This seems unusually large — check units?');
        else hideHint(hEl);
      }
    }

    function clearLargestHighlights(){
      list.querySelectorAll('.largest-label').forEach(el => el.classList.remove('largest-label'));
      list.querySelectorAll('.badge').forEach(b => {
        b.classList.add('hide');
        b.textContent = 'Largest';
      });
    }

    function setUnit(newUnit){
      if (newUnit === inputUnit) return;

      // Convert existing numbers to the new unit (circumference)
      getInputs().forEach(inp => {
        const v = parseFloat(inp.value);
        if (!Number.isNaN(v)) {
          const m = (inputUnit === 'm') ? v : v * M_PER_FT; // old -> m
          const out = (newUnit === 'm') ? m : m * FT_PER_M; // m -> new
          inp.value = out.toFixed(2);
        }
      });

      inputUnit = newUnit;
      unitTag.textContent = inputUnit;

      const isM = inputUnit === 'm';
      unitM.classList.toggle('active', isM);
      unitFt.classList.toggle('active', !isM);
      unitM.setAttribute('aria-pressed', String(isM));
      unitFt.setAttribute('aria-pressed', String(!isM));

      // Update labels & placeholders
      renumberLabels();
      getInputs().forEach(inp => { inp.placeholder = isM ? 'e.g. 1.75' : 'e.g. 5.74'; });

      markDescDirty();
    }

    function parseBulk(text){
      const nums = (text.match(/[-+]?\d*\.?\d+/g) || [])
        .map(s => parseFloat(s))
        .filter(v => Number.isFinite(v) && v > 0);
      return nums;
    }

    function fillFromBulk(){
      const vals = parseBulk(bulk.value);
      if (vals.length === 0) return;
      // rebuild rows sized to vals
      list.innerHTML = '';
      trunkCount = 0;
      vals.forEach(v => addTrunk(v.toFixed(2)));
      clearLargestHighlights();
      lastMetersCirc = '';
      copyBtn.disabled = true;
      outC.textContent = '—'; outD.textContent = '—'; outUsed.textContent = '—';
      markDescDirty();
      renumberLabels();
    }

    function sortByDiameter(){
      // Split rows into valid (with diameter in meters) and the rest
      const rows = Array.from(list.children);
      const valid = [];
      const emptyOrInvalid = [];
      rows.forEach(row => {
        const inp = row.querySelector('input[type="number"]');
        const val = parseFloat(inp.value);
        if (Number.isFinite(val) && val > 0) {
          const cMeters = (inputUnit === 'm') ? val : val * M_PER_FT;
          const dMeters = cMeters / PI;
          valid.push({ row, dMeters });
        } else {
          emptyOrInvalid.push(row);
        }
      });
      if (valid.length < 2) return; // nothing to sort

      valid.sort((a,b) => b.dMeters - a.dMeters);
      // Rebuild order
      const frag = document.createDocumentFragment();
      valid.forEach(v => frag.appendChild(v.row));
      emptyOrInvalid.forEach(r => frag.appendChild(r));
      list.innerHTML = '';
      list.appendChild(frag);
      renumberLabels();
      clearLargestHighlights();
      markDescDirty();
      // Recalculate to re-highlight and refresh outputs if there are numbers
      if (valid.length > 0) calculate(new Event('submit'));
    }

    function calculate(e){
      if (e) e.preventDefault();
      clearLargestHighlights();

      const inputs = getInputs();
      const rows = inputs.map(inp => {
        const row = inp.closest('.row');
        const hint = row.querySelector('.hint');
        const val = parseFloat(inp.value);
        inp.classList.remove('error'); hideHint(hint);

        if (Number.isNaN(val)) return { inp, row, val: NaN, ok:false };
        if (val <= 0) {
          inp.classList.add('error'); showHint(hint, 'Enter a positive number.');
          return { inp, row, val, ok:false };
        }
        maybeOutlierHint(val, hint);
        return { inp, row, val, ok:true };
      });

      const valid = rows.filter(r => r.ok);
      if (valid.length === 0) {
        inputs[0]?.classList.add('error');
        outC.textContent = '—'; outD.textContent = '—';
        outUsed.textContent = 'Please enter at least one circumference.';
        copyBtn.disabled = true; lastMetersCirc = ''; lastCalc = null;
        markDescDirty();
        return;
      }

      // circumference -> diameter (in meters)
      const withDiam = valid.map((r, i) => {
        const cMeters = (inputUnit === 'm') ? r.val : r.val * M_PER_FT;
        const dMeters = cMeters / PI;
        return { ...r, cMeters, dMeters, idx: i };
      });

      // Identify largest (ties allowed)
      const eps = 1e-9;
      const dmax = Math.max(...withDiam.map(x => x.dMeters));
      const maxRows = withDiam.filter(x => Math.abs(x.dMeters - dmax) < eps);

      // Combined diameter & circumference
      const sumAll = withDiam.reduce((acc, x) => acc + x.dMeters, 0);
      const dEqM = dmax + 0.5 * (sumAll - dmax);
      const cEqM = dEqM * PI;

      const dEqFt = dEqM * FT_PER_M;
      const cEqFt = cEqM * FT_PER_M;

      outC.textContent = `${cEqM.toFixed(2)} m (${cEqFt.toFixed(2)} ft)`;
      outD.textContent = `${dEqM.toFixed(2)} m (${dEqFt.toFixed(2)} ft)`;

      // Highlight largest; set badge text depending on tie
      const badgeText = (maxRows.length > 1) ? 'Tied for largest' : 'Largest';
      maxRows.forEach(r => {
        const lab = r.row.querySelector('.trunk-label');
        const badge = r.row.querySelector('.badge');
        if (lab) lab.classList.add('largest-label');
        if (badge) { badge.textContent = badgeText; badge.classList.remove('hide'); }
      });

      // Explain usage (with clarification)
      outUsed.textContent = (maxRows.length === 1)
        ? `Trunks used: ${withDiam.length}. Largest trunk is bolded and counted fully; all others counted at 50% (per ARA formula).`
        : `Trunks used: ${withDiam.length}. Multiple trunks are tied for largest (bolded); one is counted fully, the rest at 50% (per ARA formula).`;

      // Save details for copy + description
      lastMetersCirc = cEqM.toFixed(2);
      copyBtn.disabled = false;
      copyBtn.textContent = 'Copy result (m)';

      lastCalc = {
        unit: inputUnit,
        trunks: withDiam.map((x, idx) => {
          const cM = x.cMeters;
          const cF = cM * FT_PER_M;
          const dM = x.dMeters;
          const dF = dM * FT_PER_M;
          return {
            index: idx + 1,
            cM: cM.toFixed(2), cF: cF.toFixed(2),
            dM: dM.toFixed(2), dF: dF.toFixed(2),
            isLargest: Math.abs(dM - dmax) < eps
          };
        }),
        dEqM: dEqM.toFixed(2), cEqM: cEqM.toFixed(2),
        dEqFt: dEqFt.toFixed(2), cEqFt: cEqFt.toFixed(2),
        tie: maxRows.length > 1
      };

      // Description must be regenerated after every calc
      markDescDirty();
    }

    async function copyMeters(){
      if (!lastMetersCirc) return;
      try {
        await navigator.clipboard.writeText(lastMetersCirc);
        copyBtn.textContent = 'Copied ✓';
        setTimeout(() => { copyBtn.textContent = 'Copy result (m)'; }, 1200);
      } catch {
        const tmp = document.createElement('input');
        tmp.value = lastMetersCirc; document.body.appendChild(tmp);
        tmp.select(); document.execCommand('copy'); document.body.removeChild(tmp);
        copyBtn.textContent = 'Copied ✓';
        setTimeout(() => { copyBtn.textContent = 'Copy result (m)'; }, 1200);
      }
    }

    function generateDescription(){
      // Ensure we have a calculation
      if (!lastCalc) {
        calculate(new Event('submit'));
        if (!lastCalc) return;
      }

      // Build HTML bullets (with bold largest)
      const ul1 = document.createElement('ul');
      const title1 = document.createElement('p');
      title1.innerHTML = '<strong>Individual trunks (circumference → diameter)</strong>';
      lastCalc.trunks.forEach(t => {
        const li = document.createElement('li');
        const text = `T${t.index}: ${t.cM} m (${t.cF} ft) → ${t.dM} m (${t.dF} ft)`;
        if (t.isLargest) {
          li.innerHTML = `<strong>${text}</strong>`;
        } else {
          li.textContent = text;
        }
        ul1.appendChild(li);
      });

      const title2 = document.createElement('p');
      title2.innerHTML = '<strong>Full tree (ARA method)</strong>';
      const ul2 = document.createElement('ul');
      const liC = document.createElement('li');
      liC.textContent = `Full tree circumference: ${lastCalc.cEqM} m (${lastCalc.cEqFt} ft)`;
      const liD = document.createElement('li');
      liD.textContent = `Full tree diameter: ${lastCalc.dEqM} m (${lastCalc.dEqFt} ft)`;
      ul2.appendChild(liC);
      ul2.appendChild(liD);

      descBox.innerHTML = '';
      descBox.appendChild(title1);
      descBox.appendChild(ul1);
      descBox.appendChild(title2);
      descBox.appendChild(ul2);

      copyDescBtn.disabled = false;
      genDescBtn.classList.add('active'); // dark style after generating
    }

    // *** RICH-HTML COPY FIX ***
    async function copyDescription(){
      const html = descBox.innerHTML.trim();
      // Plain-text fallback: bullets
      const items = Array.from(descBox.querySelectorAll('li')).map(li => `- ${li.innerText}`);
      const text = items.length ? items.join('\n') : descBox.innerText.trim();
      if (!html || html === '—') return;

      if (navigator.clipboard && window.ClipboardItem) {
        try {
          const data = {
            "text/html": new Blob([html], { type: "text/html" }),
            "text/plain": new Blob([text], { type: "text/plain" })
          };
          await navigator.clipboard.write([new ClipboardItem(data)]);
          copyDescBtn.textContent = 'Copied ✓';
          setTimeout(() => { copyDescBtn.textContent = 'Copy description'; }, 1200);
          return;
        } catch (e) {
          // fall through to legacy path
        }
      }

      // Fallback: contentEditable trick to preserve formatting in most browsers
      const temp = document.createElement('div');
      temp.contentEditable = 'true';
      temp.style.position = 'fixed';
      temp.style.left = '-9999px';
      temp.innerHTML = html;
      document.body.appendChild(temp);

      const range = document.createRange();
      range.selectNodeContents(temp);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);

      try {
        document.execCommand('copy');
        copyDescBtn.textContent = 'Copied ✓';
      } finally {
        sel.removeAllRanges();
        document.body.removeChild(temp);
        setTimeout(() => { copyDescBtn.textContent = 'Copy description'; }, 1200);
      }
    }

    function resetAll(){
      setTimeout(() => {
        list.innerHTML = '';
        trunkCount = 0;
        addTrunk(); addTrunk();
        lastMetersCirc = ''; lastCalc = null;
        copyBtn.disabled = true;
        copyBtn.textContent = 'Copy result (m)';
        outC.textContent = '—'; outD.textContent = '—'; outUsed.textContent = '—';
        clearLargestHighlights();
        markDescDirty();
        renumberLabels();
      }, 0);
    }

    // Init
    addTrunk(); addTrunk();

    // Events
    form.addEventListener('submit', calculate);
    form.addEventListener('reset', resetAll);
    addBtn.addEventListener('click', () => { addTrunk(); markDescDirty(); });
    remBtn.addEventListener('click', () => { if (trunkCount > 1) removeTrunk(); });
    sortBtn.addEventListener('click', sortByDiameter);
    $('#fill').addEventListener('click', fillFromBulk);
    $('#clear-bulk').addEventListener('click', () => { bulk.value = ''; });
    unitM.addEventListener('click', () => setUnit('m'));
    unitFt.addEventListener('click', () => setUnit('ft'));
    $('#copy').addEventListener('click', copyMeters);
    genDescBtn.addEventListener('click', generateDescription);
    copyDescBtn.addEventListener('click', copyDescription);
  </script>
</body>
</html>
